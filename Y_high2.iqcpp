{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor UPDOWNMotorA = motor(PORT5, false);\nmotor UPDOWNMotorB = motor(PORT11, true);\nmotor_group UPDOWN = motor_group(UPDOWNMotorA, UPDOWNMotorB);\n\ncontroller Controller = controller();\nmotor armMotorA = motor(PORT4, false);\nmotor armMotorB = motor(PORT10, true);\nmotor_group arm = motor_group(armMotorA, armMotorB);\n\npneumatic Pneumatic1 = pneumatic(PORT1);\nmotor leftM = motor(PORT6, true);\nmotor rightM = motor(PORT12, false);\ndistance leftdistance = distance(PORT2);\ndistance rightdistance = distance(PORT3);\ntouchled TouchLED7 = touchled(PORT7);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       {author}                                                  \n//    Created:      {date}                                                    \n//    Description:  IQ project                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\nint claw=0,upclaw=0;\nint chasiss();int cha,chc;int armstate=1;\nint ctchas=1,autostate=0;\nint doublepin=0;\nvoid move(int a,int c);\nint breakauto=0;\nint autorun();\nint side=0;//默认蓝色方\nvoid run_dir_speed(double degree,double speed);\ndouble kp=0.7,ki=0.001,kd=0.8,err,integ,deri,lasterr,pid;\nvoid run_dir_speed_dis(double degree,double speed,double dis,bool st=true);\nvoid run_dir_speed_time(double degree,double speed,double time,bool st=true);\nvoid turnto(int degree);\ndouble tkp=0.8 ,tki=0.004,tkd=0.6,terr,tinteg,tderi,tlasterr,tpid;\nvoid armslowto();void delay(double t);\nint upmini=2;\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  Pneumatic1.pumpOff();\n  BrainInertial.calibrate();\n  while(BrainInertial.isCalibrating())\n  {wait(1,msec);}\n  Pneumatic1.pumpOn();\n  arm.setStopping(brake);\n  leftM.setStopping(brake);\n  rightM.setStopping(brake);\n  arm.setPosition(0,degrees);\n  UPDOWN.setStopping(brake);\n  UPDOWN.setPosition(0,degrees);\n  arm.setPosition(0,degrees);\n  vex::task ctchass(chasiss);\n  vex::task autor(autorun);\n  // Begin project code\n  Pneumatic1.extend(cylinder2);\n  Pneumatic1.retract(cylinder1);\n  Pneumatic1.pumpOn();\n  \n  while(1)\n  {\n    Brain.Screen.printAt(60,20,\"%d\",claw);\n    Brain.Screen.printAt(100,20,\"%d\",doublepin);\n    if(Controller.ButtonFDown.pressing()==1)\n    {\n      Brain.Timer.reset();\n      while(Controller.ButtonFDown.pressing()==1)\n      {\n        wait(1,msec);\n        if(Brain.Timer.value()>0.5)\n        {\n          doublepin+=1;\n          if (doublepin%2==1)\n          {\n            TouchLED7.setColor(yellow);\n          }\n          else \n          {\n            TouchLED7.setColor(green);\n          }\n          while(Controller.ButtonFDown.pressing()==1)\n          {\n            wait(1,msec);\n          }\n        }\n      }\n      \n    }\n    wait(5,msec);\n    if (Controller.ButtonRDown.pressing()&&armMotorA.position(degrees)>0)\n    {\n      if(doublepin%2==0)\n        {\n          arm.setStopping(brake);\n          arm.setVelocity(-80,percent);\n          arm.spinToPosition(0,degrees,false);\n          armstate=1;\n        }\n        else \n        {\n          arm.setVelocity(-40,percent);\n          arm.spinToPosition(0,degrees,false);\n        }\n    }\n    else if(Controller.ButtonRUp.pressing())\n    {\n      if(arm.position(degrees)<540)\n      {\n        arm.setStopping(hold);\n      }\n      else \n      {\n        arm.setStopping(brake);\n      }\n      if(arm.position(degrees)<260)\n      {//\n        if(doublepin%2==0)\n          {arm.spin(forward,100,percent);}\n        else \n        {\n          arm.spin(forward,50,percent);\n          arm.spinToPosition(140,degrees,true);\n        }\n      }\n      else \n      {\n        arm.spin(forward,50,percent);\n      }\n    }\n    else \n    {\n      if(UPDOWN.position(degrees)>130&&arm.position(degrees)>230)\n      {\n        arm.setVelocity(100,percent);\n        arm.spinToPosition(230,degrees,true);\n      }\n      else if(autostate==0)\n      {\n        arm.stop();\n      }\n    }\n    if (Controller.ButtonEUp.pressing())\n    {\n      while(Controller.ButtonEUp.pressing())\n      {wait(5,msec);}\n      if(doublepin%2==1&&claw%2==1&&arm.position(degrees)<20)\n      {\n        Pneumatic1.extend(cylinder1);\n        wait(0.7,seconds);  \n      }\n      claw+=1;\n    }\n    if (claw%2==0)\n    {\n        Pneumatic1.extend(cylinder1);\n    }\n    if((claw%2==0&&ctchas==1&&doublepin%2==1&&(leftdistance.objectDistance(mm)<85||rightdistance.objectDistance(mm)<85)&&arm.position(degrees)<15&&arm.velocity(percent)==0))\n    {\n      ctchas=0;\n      move(30,30);\n      wait(0.25,seconds);\n      Pneumatic1.retract(cylinder1);\n      claw=1;\n      ctchas=1;\n    }\n    else if(claw%2==1||(leftdistance.objectDistance(mm)<85&&rightdistance.objectDistance(mm)<85&&arm.position(degrees)<15&&arm.velocity(percent)==0))\n    {\n      \n      Pneumatic1.retract(cylinder1);\n      claw=1;\n    }\n    if (Controller.ButtonFUp.pressing())\n    {\n      while(Controller.ButtonFUp.pressing()==1)\n      {wait(5,msec);}\n      upclaw+=1;\n      if (upclaw%2==1)\n      {\n        Pneumatic1.retract(cylinder2);\n        wait(0.2,seconds);\n        upmini=1;\n      }\n      else \n      {\n        Pneumatic1.extend(cylinder2);\n        wait(0.2,seconds);\n        upmini=0;\n      } \n    }\n    \n  }\n}\nint chasiss()\n{\n  TouchLED7.setColor(blue);\n  while(1)\n  {\n    wait(5,msec);\n    if (Controller.ButtonEDown.pressing()==1)\n    {\n      Brain.Timer.reset();\n      while(Controller.ButtonEDown.pressing()==1)\n      {\n        wait(2,msec);\n        if(Brain.Timer.value()>0.5)\n        {\n          BrainInertial.setRotation(0,degrees);\n          doublepin=0;\n          autostate=1;\n        }\n      }\n      while(Brain.Timer.value()<0.5)\n      {\n        wait(1,msec);\n        if(Controller.ButtonEDown.pressing()==1)\n        {\n          while((Controller.ButtonEDown.pressing()==1))\n          {\n            wait(1,msec);\n          }\n          doublepin=0;\n          side+=1;\n          if(side%2==1)\n          {\n            TouchLED7.setColor(red);\n          }\n          else \n          {\n            TouchLED7.setColor(blue);\n          }\n        }\n      }\n    }\n    if (fabs(Controller.AxisA.position())>30)\n    {\n      breakauto=1;\n    }\n    if (ctchas==1)\n    { \n      if (fabs(Controller.AxisA.position())>12)\n      {\n        cha=Controller.AxisA.position();\n      }\n      else \n      {\n        cha=0;\n      }\n      if (fabs(Controller.AxisC.position())>12)\n      {\n        chc=Controller.AxisC.position();\n      }\n      else \n      {\n        chc=0;\n      }\n      leftM.spin(forward,cha+0.6*chc,percent);\n      rightM.spin(forward,cha-0.6*chc,percent);\n    }\n  }\n}\nint autorun()\n{\n  while(1)\n  {\n    if(Controller.ButtonLUp.pressing())\n    {\n      if(UPDOWN.position(degrees)<700)\n      {\n        UPDOWN.setVelocity(100,percent);\n      }\n      else \n      {\n        UPDOWN.setVelocity(20,percent);\n      }\n      UPDOWN.spinToPosition(850,degrees,false);\n      UPDOWN.setStopping(hold);\n    }\n    else if (Controller.ButtonLDown.pressing())\n    {\n\n      if(UPDOWN.position(degrees)>100)\n      {\n        UPDOWN.setVelocity(-80,percent);\n      }\n      else \n      {\n        UPDOWN.setVelocity(-40,percent);\n      }\n      UPDOWN.spinToPosition(0,degrees,false);\n      UPDOWN.setStopping(hold);\n    }\n    else \n    {\n      if (upmini==1&&UPDOWN.position(degrees)<100)\n      {\n        UPDOWN.setVelocity(20,percent);\n        UPDOWN.spinToPosition(50,degrees,true);\n        upmini=2;\n      }\n      else if(upmini==0&&UPDOWN.position(degrees)<100)\n      {\n        UPDOWN.setVelocity(20,percent);\n        UPDOWN.spinToPosition(0,degrees,true);\n        upmini=2;\n      }\n      else if(autostate==0)\n      {\n        UPDOWN.stop();\n      }\n    }\n    wait(5,msec);\n    if (autostate==1)\n    {\n      ctchas=0;\n      if(side%2==0)\n      {\n        breakauto=0;\n        Pneumatic1.pumpOff();\n        wait(0.1,seconds);\n        BrainInertial.setRotation(0,degrees);\n        ctchas=0;\n        upclaw=0;\n        BrainInertial.setRotation(0,degrees);\n        UPDOWN.setVelocity(20,percent);\n        UPDOWN.spinToPosition(0,degrees,false);\n        Pneumatic1.extend(cylinder2);\n        run_dir_speed_dis(15,70,15,false);\n        run_dir_speed_dis(17,70,8,false);\n        claw=1;\n        run_dir_speed_dis(17,70,3.5,true);\n        Pneumatic1.pumpOn();\n        arm.spinToPosition(300,degrees,false);\n        run_dir_speed_dis(-72,50,14.5,true);\n        run_dir_speed_dis(-60,-35,2.5,true);\n        //leftM.spinFor(forward,-180,degrees,false);\n        //rightM.spinFor(forward,180,degrees,true);\n        turnto(-135);\n        run_dir_speed_time(-135,-80,1.1,true);\n        upclaw=1;\n        Pneumatic1.retract(cylinder2);\n        upclaw=1;\n        Pneumatic1.retract(cylinder2);\n        delay(0.1);\n        UPDOWN.spinToPosition(60,degrees,true);\n        arm.setVelocity(90,percent);\n        arm.spinToPosition(550,degrees,false);\n        run_dir_speed_dis(-135,40,4,true);\n        delay(0.3);\n        claw=0;\n        Pneumatic1.extend(cylinder1);\n        delay(0.1);\n        arm.setVelocity(80,percent);\n        arm.spinToPosition(0,degrees,false);\n        delay(0.3);\n        turnto(-85);\n        claw=0;\n        run_dir_speed_dis(-85,40,3,true);\n        claw=0;\n      }\n      else \n      {\n        breakauto=0;\n        Pneumatic1.pumpOff();\n        BrainInertial.setRotation(0,degrees);\n        ctchas=0;\n        upclaw=0;\n        BrainInertial.setRotation(0,degrees);\n        UPDOWN.setVelocity(20,percent);\n        UPDOWN.spinToPosition(0,degrees,false);\n        Pneumatic1.extend(cylinder2);\n        run_dir_speed_dis(-15,70,15,false);\n        run_dir_speed_dis(-17,70,8,false);\n        claw=1;\n        run_dir_speed_dis(-17,70,3.5,true);\n        Pneumatic1.pumpOn();\n        arm.spinToPosition(300,degrees,false);\n        run_dir_speed_dis(72,50,14.5,true);\n        run_dir_speed_dis(60,-35,2.5,true);\n        //leftM.spinFor(forward,-180,degrees,false);\n        //rightM.spinFor(forward,180,degrees,true);\n        turnto(135);\n        run_dir_speed_time(135,-80,1.1,true);\n        upclaw=1;\n        Pneumatic1.retract(cylinder2);\n        upclaw=1;\n        Pneumatic1.retract(cylinder2);\n        delay(0.1);\n        UPDOWN.spinToPosition(60,degrees,true);\n        arm.setVelocity(90,percent);\n        arm.spinToPosition(550,degrees,false);\n        run_dir_speed_dis(135,40,4,true);\n        delay(0.3);\n        claw=0;\n        Pneumatic1.extend(cylinder1);\n        delay(0.1);\n        arm.setVelocity(80,percent);\n        arm.spinToPosition(0,degrees,false);\n        delay(0.3);\n        turnto(85);\n        claw=0;\n        run_dir_speed_dis(85,40,3,true);\n        claw=0;\n      }\n      autostate=0;\n      ctchas=1;\n    }\n  }\n}\nvoid run_dir_speed(double degree,double speed)\n{\n  wait(10,msec);\n  err=degree-BrainInertial.rotation(degrees);\n  if (fabs(err)>15||fabs(err)<2)\n  {\n    integ=0;\n  }\n  else \n  {\n    integ+=err;\n  }\n\n  deri=err-lasterr;\n  pid = err*kp+integ*ki+deri*kd;\n  move(speed+pid,speed-pid);\n  lasterr=err;\n}\nvoid run_dir_speed_dis(double degree,double speed,double dis,bool st)\n{\n  integ=0;deri=0;lasterr=0;\n  leftM.setPosition(0,degrees);\n  rightM.setPosition(0,degrees);\n  while(fabs(leftM.position(degrees))+fabs(rightM.position(degrees))<dis*100)\n  {\n    run_dir_speed(degree,speed);\n    if(breakauto==1)\n    {\n      break;\n    }\n  }\n  if (st==true)\n  {\n    move(0,0);\n  }\n}\nvoid run_dir_speed_time(double degree,double speed,double time,bool st)\n{\n  Brain.Timer.reset();\n  while(Brain.Timer.value()<time)\n  {\n    run_dir_speed(degree,speed);\n    if(breakauto==1)\n    {\n      break;\n    }\n  }\n  if (st==true)\n  {\n    move(0,0);\n  }\n}\nvoid turnto(int degree)\n{\n  int count=0;\n  while(1)\n  {\n    if(breakauto==1)\n    {\n      break;\n    }\n    wait(10,msec);\n    terr=degree-BrainInertial.rotation(degrees);\n    if (fabs(terr)>20||fabs(terr)<3)\n    {\n      tinteg=0;\n    }\n    else \n    {\n      tinteg+=terr;\n    }\n      if(fabs(terr)<3)\n    {\n      count+=1;\n      if (count>15)\n      {\n        break;\n      }\n    }\n    tderi=terr-tlasterr;\n    tpid = terr*tkp+tinteg*tki+tderi*tkd;\n    move(tpid,-tpid);\n    tlasterr=terr;\n  }\n  move(0,0);\n}\nvoid move(int a,int c)\n{\n  leftM.spin(forward,a,percent);\n  rightM.spin(forward,c,percent);\n}\nvoid delay(double t)\n{\n  Brain.Timer.reset();\n  while(Brain.Timer.value()<t)\n  {\n    wait(1,msec);\n    if(breakauto==1)\n    {\n      break;\n    }\n  }\n}","textLanguage":"cpp","robotConfig":[{"port":[5,11],"name":"UPDOWN","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"向前","rev":"反","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[4,10],"name":"arm","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"向前","rev":"反","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[1],"name":"Pneumatic1","customName":false,"deviceType":"Pneumatic","deviceClass":"pneumatic","setting":{"cylinder1":"气缸1","cylinder2":"气缸2","cylinder1_reversed":"false","cylinder2_reversed":"false","cylinder3":"","cylinder4":""},"triportSourcePort":22},{"port":[6],"name":"leftM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"向前","rev":"反"},"triportSourcePort":22},{"port":[12],"name":"rightM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"向前","rev":"反"},"triportSourcePort":22},{"port":[2],"name":"leftdistance","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[3],"name":"rightdistance","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[7],"name":"TouchLED7","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22}],"slot":1,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":""}}